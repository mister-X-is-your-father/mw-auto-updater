# 並列エージェント処理戦略

Claude Code で複数エージェント（Task ツール）を効率的に使用するための戦略ガイド。

## 基本方針

1. **ボトルネックを事前に特定**する
2. **独立したタスクは並列実行**する
3. **重いタスクには複数エージェント**を割り当てる

---

## 1. タスク分析フレームワーク

### Step 1: タスクの分解

大きなタスクを小さな単位に分解する。

```
例: 「新機能を実装する」

├─ 設計・調査
│   ├─ 既存コードの分析
│   ├─ 技術選定の調査
│   └─ 設計ドキュメント作成
│
├─ 実装
│   ├─ バックエンド実装
│   ├─ フロントエンド実装
│   └─ テスト実装
│
└─ 仕上げ
    ├─ ドキュメント更新
    ├─ 動作確認
    └─ コミット
```

### Step 2: 依存関係の特定

```
[設計] ──→ [実装] ──→ [テスト] ──→ [コミット]
              │
              ├─ [バックエンド] ──┐
              │                  ├─→ [統合]
              └─ [フロントエンド]─┘
```

**ルール:**
- 矢印のないタスク同士 → 並列実行可能
- 矢印で繋がっているタスク → 順次実行

### Step 3: ボトルネックの特定

| 判断基準 | 重み | 例 |
|---------|------|-----|
| 作業量 | 高 | 200行以上のコード、複数ファイル |
| 複雑度 | 中 | 複雑なロジック、外部API連携 |
| 待ち時間 | 中 | ビルド、API呼び出し |
| 不確実性 | 低 | 調査が必要、要件が曖昧 |

---

## 2. エージェント割り当て戦略

### 基本ルール

```
タスクの性質        → 推奨エージェント数
─────────────────────────────────────
調査・分析タスク    → 2〜3（視点を分散）
大規模実装         → 2〜3（分割実装）
小規模実装         → 1
独立したテスト     → 最大並列
ドキュメント更新   → 1〜2
```

### 割り当て判断フロー

```
タスクを評価
    │
    ├─ 作業量が大きい？
    │   └─ Yes → 分割して複数エージェント
    │
    ├─ 複数の視点が必要？
    │   └─ Yes → 異なる専門のエージェント
    │
    ├─ 他タスクと独立？
    │   └─ Yes → 並列実行リストに追加
    │
    └─ 依存関係あり？
        └─ Yes → 前タスク完了後に実行
```

---

## 3. 並列実行パターン

### パターン A: 調査フェーズ（視点分散型）

同じ問題を異なる角度から調査する。

```
┌────────────────┬────────────────┬────────────────┐
│ 設計視点       │ 実装視点       │ 運用視点       │
│ アーキテクチャ │ コード分析     │ ベストプラクティス│
└────────────────┴────────────────┴────────────────┘
                        ↓
                   結果を統合
```

**使用場面:**
- 技術選定
- 設計レビュー
- 問題調査

### パターン B: 実装フェーズ（分割実装型）

大きな実装を独立した部分に分割する。

```
┌────────────────┬────────────────┬────────────────┐
│ モジュールA    │ モジュールB    │ モジュールC    │
│ 実装           │ 実装           │ 実装           │
└────────────────┴────────────────┴────────────────┘
                        ↓
                   統合・テスト
```

**使用場面:**
- 複数ファイルの作成
- 独立した機能の実装
- マイクロサービス開発

### パターン C: テストフェーズ（最大並列型）

独立したテストを同時実行する。

```
┌──────────┬──────────┬──────────┬──────────┐
│ テストA  │ テストB  │ テストC  │ テストD  │
└──────────┴──────────┴──────────┴──────────┘
```

**使用場面:**
- 単体テスト実行
- 複数環境での確認
- リグレッションテスト

### パターン D: ハイブリッド型

異なる種類のタスクを同時実行する。

```
┌────────────────┬────────────────┬────────────────┐
│ メイン実装     │ ドキュメント   │ 設定ファイル   │
│ (重い)         │ (軽い)         │ (軽い)         │
└────────────────┴────────────────┴────────────────┘
```

**使用場面:**
- 実装中のドキュメント作成
- コードと設定の同時更新

---

## 4. 実践的なワークフロー

### フェーズ 1: 計画（5分）

```
1. タスクをリストアップ
2. 依存関係を図示
3. ボトルネックをマーク
4. エージェント数を決定
```

### フェーズ 2: 実行

```
Round 1: 調査・設計
    ├─ 複数エージェントで並列調査
    └─ 結果を統合して方針決定

Round 2: 実装
    ├─ 独立モジュールを並列実装
    └─ 依存モジュールは順次実装

Round 3: 仕上げ
    ├─ テスト・確認を並列実行
    └─ ドキュメント・コミット
```

### フェーズ 3: 統合

```
1. 各エージェントの結果を確認
2. 競合があれば解決
3. 全体の整合性を確認
```

---

## 5. 指示の書き方

### 良い指示の例

```
以下のタスクを3つのエージェントで並列実行してください：

【エージェント1: バックエンド】
- /src/api/ 配下に認証APIを実装
- 入力: ユーザー名、パスワード
- 出力: JWTトークン

【エージェント2: フロントエンド】
- /src/components/ にログインフォームを作成
- React + TypeScript
- バリデーション付き

【エージェント3: テスト】
- /tests/ に認証のテストを作成
- 正常系・異常系の両方

依存関係: なし（モック使用で独立実行可能）
統合方法: 全完了後にE2Eテストで確認
```

### 悪い指示の例

```
❌ 認証機能を作って
（タスクが曖昧、分割されていない）

❌ 3つのエージェントで何かやって
（具体的なタスクがない）

❌ バックエンドを先に、それからフロントを
（並列化の意図がない）
```

---

## 6. アンチパターン

| パターン | 問題 | 対策 |
|---------|------|------|
| 全て直列実行 | 時間がかかりすぎる | 独立タスクを特定して並列化 |
| 全て並列実行 | 依存関係でエラー | 依存グラフを作成 |
| 1エージェントに大量タスク | 処理が遅い | タスクを分割 |
| 結果を確認せず次へ | 手戻りが発生 | 各フェーズで確認 |
| 曖昧な指示 | 期待と異なる結果 | 具体的に記述 |

---

## 7. チェックリスト

### 並列実行前

- [ ] タスクを小さな単位に分解したか
- [ ] 依存関係を特定したか
- [ ] ボトルネックを特定したか
- [ ] 各エージェントの担当を明確にしたか
- [ ] 統合方法を決めたか

### 並列実行後

- [ ] 全エージェントが完了したか
- [ ] 結果に矛盾がないか
- [ ] 統合して動作確認したか
- [ ] ドキュメントを更新したか

---

## 8. 参考：エージェント数の目安

| プロジェクト規模 | 推奨並列数 | 理由 |
|----------------|----------|------|
| 小（1-2ファイル） | 1-2 | オーバーヘッドが無駄 |
| 中（3-10ファイル） | 2-3 | バランスが良い |
| 大（10+ファイル） | 3-5 | ボトルネック解消 |

**注意:** 並列数を増やしすぎると統合コストが増加する。
