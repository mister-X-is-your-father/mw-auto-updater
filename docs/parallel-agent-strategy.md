# 並列エージェント処理戦略

Claude Code で複数エージェントを使用する際の戦略ガイド。

## 基本方針

1. **ボトルネックを事前に特定**する
2. **独立したタスクは並列実行**する
3. **コード量が多いタスクには複数エージェント**を割り当てる

---

## 1. フェーズ分析 → ボトルネック特定

```
タスク例: 3工程のディレクトリ構造実装

フェーズ1: 設計・分析（並列度: 3）
├─ 工程設計エージェント      ← 全体アーキテクチャ
├─ 既存コード分析エージェント ← 移植対象の特定
└─ ベストプラクティス調査    ← 実装パターンの選定

フェーズ2: 実装（並列度: 3〜5）
├─ 2_fetch 実装エージェント   ← ボトルネック（コード量大）
├─ 3_review 実装エージェント
├─ 4_analyze 実装エージェント ← ボトルネック（コード量大）
├─ 5_report 実装エージェント
└─ README 更新エージェント

フェーズ3: テスト・確認（並列度: 4）
├─ 1_config テスト
├─ 2_fetch テスト
├─ .gitkeep/.gitignore 設定
└─ ディレクトリ構造確認
```

---

## 2. ボトルネック予測基準

| 判断基準 | 重み | 例 |
|---------|------|-----|
| コード量 | 高 | 200行以上のスクリプト |
| 外部依存 | 中 | API呼び出し、ファイル読み込み |
| 複雑度 | 中 | ロジックの複雑さ |
| 人間確認必要 | 低 | レビュー待ち |

### ボトルネック判定フロー

```
タスクを評価
    │
    ├─ コード量 > 200行？ ─── Yes → ボトルネック（高）
    │
    ├─ 外部API呼び出しあり？ ── Yes → ボトルネック（中）
    │
    ├─ 複雑なロジック？ ───── Yes → ボトルネック（中）
    │
    └─ 単純な設定/コピー？ ── Yes → 通常タスク
```

---

## 3. エージェント割り当てルール

```python
# 擬似コード
def assign_agents(tasks):
    bottlenecks = identify_bottlenecks(tasks)

    # ボトルネックには多くのエージェントを割り当て
    for task in bottlenecks:
        if task.code_size > 200:
            agents = 2  # 分割実装
        else:
            agents = 1

    # 独立タスクは並列実行
    independent_tasks = [t for t in tasks if no_dependencies(t)]
    run_parallel(independent_tasks)
```

### 割り当て例

| タスク種別 | エージェント数 | 理由 |
|-----------|--------------|------|
| 設計・調査 | 3 | 視点を分散させる |
| 大規模実装 | 2 | 分割して並列実装 |
| 小規模実装 | 1 | 単体で十分 |
| テスト | 4+ | 独立なので最大並列 |

---

## 4. 実際の並列パターン

### Round 1: 設計フェーズ（3並列）

```
┌────────────────┬────────────────┬────────────────┐
│ Plan Agent     │ Explore Agent  │ General Agent  │
│ 設計検討       │ 既存コード分析  │ ベストプラクティス│
└────────────────┴────────────────┴────────────────┘
```

**目的**: 異なる視点から情報を収集し、設計の質を高める

### Round 2: 実装フェーズ（3並列）

```
┌────────────────┬────────────────┬────────────────┐
│ 2_fetch        │ 3_review       │ 4_analyze      │
│ 実装           │ 実装           │ 実装           │
└────────────────┴────────────────┴────────────────┘
```

**目的**: 独立したモジュールを同時に実装

### Round 3: 補完フェーズ（3並列）

```
┌────────────────┬────────────────┬────────────────┐
│ 5_report       │ README         │ Bash           │
│ 実装           │ 更新           │ .gitkeep設定   │
└────────────────┴────────────────┴────────────────┘
```

**目的**: 残りのタスクを並列で完了

### Round 4: テストフェーズ（4並列）

```
┌──────────┬──────────┬──────────┬──────────┐
│ 1_config │ 2_fetch  │ .gitkeep │ 構造確認  │
│ テスト   │ テスト   │ 設定     │          │
└──────────┴──────────┴──────────┴──────────┘
```

**目的**: 独立したテストを最大並列で実行

---

## 5. 依存関係の管理

### 依存グラフの例

```
設計完了
    │
    ├──────────────┬──────────────┐
    ▼              ▼              ▼
2_fetch実装   3_review実装   4_analyze実装
    │              │              │
    └──────────────┼──────────────┘
                   ▼
              README更新
                   │
                   ▼
                テスト
                   │
                   ▼
               コミット
```

### ルール

1. **依存がないタスク** → 並列実行OK
2. **依存があるタスク** → 前のタスク完了を待つ
3. **部分的に依存** → 依存部分だけ待つ

---

## 6. 改善ポイント

### より効率的にするには

1. **事前にタスクグラフを作成**
   - 依存関係を可視化してから開始
   - クリティカルパスを特定

2. **ボトルネックに複数エージェント**
   - 大きなファイルは分割実装
   - 例: 前半/後半、機能A/機能B

3. **待ち時間を活用**
   - エージェント完了待ちの間に別タスクを先行
   - Bash ツールで軽いタスクを実行

4. **結果の統合を計画**
   - 並列実装後のマージ方法を事前に決める
   - 競合が起きやすい箇所を把握

---

## 7. アンチパターン

### 避けるべきこと

| パターン | 問題 | 対策 |
|---------|------|------|
| 全て直列実行 | 時間がかかりすぎる | 独立タスクを特定して並列化 |
| 全て並列実行 | 依存関係でエラー | 依存グラフを作成 |
| 1エージェントに大量タスク | 処理が遅い | タスクを分割 |
| 結果を確認せず次へ | 手戻りが発生 | 各フェーズで確認 |

---

## 8. テンプレート

### 並列実行の指示例

```
以下のタスクを3つのエージェントで並列実行してください：

1. エージェントA: [タスク内容]
2. エージェントB: [タスク内容]
3. エージェントC: [タスク内容]

依存関係: なし（独立して実行可能）
```

### ボトルネック対応の指示例

```
[タスク名] はコード量が多いため、以下のように分割してください：

- エージェント1: [前半部分]
- エージェント2: [後半部分]

統合方法: [具体的な方法]
```
